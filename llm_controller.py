import json
import random
from typing import Dict, List, Any, Optional, Callable
import traceback
from behavior import BehaviorFactory
from event_system import EventCallback, Event

class LLMController:
    """Controller for integrating LLM with the simulation"""
    def __init__(self, api_key: str = None, environment=None):
        self.api_key = api_key
        self.environment = environment
    
    def _generate_random_position(self):
        """Generate a random position within the environment's bounds"""
        if not self.environment:
            return {"x": random.randint(0, 10), "y": random.randint(0, 10)}
        
        return {
            "x": random.randint(0, self.environment.width - 1),
            "y": random.randint(0, self.environment.height - 1)
        }
    
    async def process_goal(self, goal_text: str, environment, drones: List, use_mock: bool = False) -> Dict:
        """Process a natural language goal and generate commands for drones"""
        self.environment = environment
        
        if use_mock:
            print(f"Processing goal: {goal_text}")
            print("LLM would normally generate commands for the drones here")
            print("Drones are already configured for searching and will explore automatically")
            
            # For demonstration, issue a specific command to one drone using the correct format
            if drones:
                # Make sure we're using the drone_id properly
                drone_id = drones[0].drone_id
                # Format command with no space between 'drone' and the ID number
                command = f"move drone{drone_id} up=2 and right=3"
                try:
                    environment.command_processor.process_command(command, environment)
                    print(f"Successfully issued command: {command}")
                except Exception as e:
                    print(f"Error issuing command: {e}")
            
            return {"status": "success", "message": "Drones are searching the environment"}
        
        # For a real LLM implementation, you would:
        # 1. Send the goal to the LLM
        # 2. Get back specific commands to issue to specific drones
        # 3. Use command_processor to execute those commands
        
        # Non-mock implementation would go here...
    
    def execute_plan(self, plan: Dict, environment, drones: List) -> bool:
        """Execute a plan generated by the LLM"""
        try:
            # Process drone assignments
            drone_map = {drone.drone_id: drone for drone in drones}
            
            for assignment in plan.get("drone_assignments", []):
                drone_id = assignment["drone_id"]
                if drone_id in drone_map:
                    drone = drone_map[drone_id]
                    behavior_spec = assignment["behavior"]
                    
                    # Create and assign behavior
                    behavior = BehaviorFactory.create_behavior(
                        behavior_spec["type"],
                        behavior_spec["params"]
                    )
                    
                    if behavior:
                        drone.set_behavior(behavior)
            
            # Set up event handlers
            for handler_spec in plan.get("event_handlers", []):
                event_type = handler_spec["event_type"]
                handler_code = handler_spec["handler_code"]
                
                # Compile and register the handler
                try:
                    # This is unsafe for production - would need sandboxing
                    handler_scope = {}
                    exec(handler_code, handler_scope)
                    handler_func = handler_scope.get("handler")
                    
                    if handler_func:
                        callback = EventCallback(handler_func)
                        environment.event_manager.register(event_type, callback)
                except Exception as e:
                    print(f"Error compiling event handler: {e}")
                    traceback.print_exc()
            
            return True
        
        except Exception as e:
            print(f"Error executing plan: {e}")
            traceback.print_exc()
            return False
    
    def parse_json_instructions(self, json_str: str) -> Dict:
        """Parse JSON instructions from LLM response"""
        try:
            return json.loads(json_str)
        except json.JSONDecodeError:
            print("Error parsing JSON instructions")
            return {}

    def generate_command(self, target_position, drone_id=1):
        """Generate a movement command to reach a target position.
        
        Args:
            target_position: Position object with x,y coordinates
            drone_id: ID of the drone to move (defaults to 1)
            
        Returns:
            str: Command string in format "move droneX up=Y right=Z"
        """
        # Calculate distances to move vertically and horizontally
        vertical_dist = target_position.y - self.environment.drones[drone_id-1].position.y
        horizontal_dist = target_position.x - self.environment.drones[drone_id-1].position.x
        
        # Build command string with absolute distances
        command_parts = []
        if vertical_dist != 0:
            direction = "up" if vertical_dist < 0 else "down"
            command_parts.append(f"{direction}={abs(vertical_dist)}")
            
        if horizontal_dist != 0:
            direction = "left" if horizontal_dist < 0 else "right" 
            command_parts.append(f"{direction}={abs(horizontal_dist)}")
            
        return f"move drone{drone_id} " + " and ".join(command_parts)